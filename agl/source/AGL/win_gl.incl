////////////////////////////////////////////////////////////////////////////////
//
// This file is part of the Abstract Graphics Library.
//
// Copyright (c) 2012, bitbyte studios
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// 
////////////////////////////////////////////////////////////////////////////////

#include <AGL/win_agl.h>

#include <GL/wglext.h>

#include <time.h>

struct aglContext {
    int32_t   id;
    HWND      hWnd;
    HDC       hDC;
    HGLRC     hRC;
    unsigned  vsync      : 1;
    unsigned  fullscreen : 1;
    unsigned  reserved   : 6;
    uint32_t  gl_version;
    CGcontext cg_context;
    CGprofile cg_vs_profile;
    CGprofile cg_ps_profile;
};

static aglContext* active_context = NULL;

static int AGL_API waglCreateHGLRC( const aglContextSettings* settings, aglContext* context )
{
    PIXELFORMATDESCRIPTOR pfd;
    int32_t pixel_format;

    struct {
        HGLRC hRC;
    } dummy_context;

    int32_t major_ver, minor_ver;
    uint32_t num_formats;

    PFNWGLCHOOSEPIXELFORMATARBPROC  wglChoosePixelFormatARB;
    PFNWGLCREATECONTEXTATTRIBSARBPROC wglCreateContextAttribsARB;

    const int32_t pfd_attributes[] = {
        WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,
        WGL_ACCELERATION_ARB,   WGL_FULL_ACCELERATION_ARB,
        WGL_COLOR_BITS_ARB,     24,
        WGL_ALPHA_BITS_ARB,     0,
        WGL_DEPTH_BITS_ARB,     24,
        WGL_STENCIL_BITS_ARB,   8,
        WGL_DOUBLE_BUFFER_ARB,  GL_TRUE,
        WGL_SAMPLE_BUFFERS_ARB, settings->samples > 0 ? GL_TRUE : GL_FALSE,
        WGL_SAMPLES_ARB,        settings->samples,
        NULL, NULL
    };

    int32_t context_attributes[] = {
        WGL_CONTEXT_MAJOR_VERSION_ARB, 0,
        WGL_CONTEXT_MINOR_VERSION_ARB, 0, 
        WGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,
        WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
        NULL, NULL
    };


    ZeroMemory(&pfd, sizeof(PIXELFORMATDESCRIPTOR));
    pfd.nSize        = sizeof(PIXELFORMATDESCRIPTOR);
    pfd.nVersion     = 1; 
    pfd.dwFlags      = PFD_DOUBLEBUFFER | PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW;  
    pfd.iPixelType   = PFD_TYPE_RGBA; 
    pfd.cColorBits   = 24;
    pfd.cAlphaBits   = 0;
    pfd.cDepthBits   = 24; 
    pfd.cStencilBits = 8;
    pfd.iLayerType   = PFD_MAIN_PLANE;


    context->hDC = GetDC(context->hWnd);
    pixel_format = ChoosePixelFormat(context->hDC, &pfd);
    if( !pixel_format ) goto failure;
    if( !SetPixelFormat(context->hDC, pixel_format, &pfd) ) goto failure;
    if( !(dummy_context.hRC = wglCreateContext(context->hDC)) ) goto failure;

    wglMakeCurrent(context->hDC, dummy_context.hRC);
    glGetIntegerv(GL_MAJOR_VERSION, (GLint*)&major_ver);
    glGetIntegerv(GL_MINOR_VERSION, (GLint*)&minor_ver);

    // Default to OpenGL 2.1:

    if( major_ver < 3 ) {
        if( major_ver < 2 ) {
            wglMakeCurrent(NULL, NULL);
            wglDeleteContext(dummy_context.hRC);
            goto failure;
        } else if( minor_ver < 1 ) {
            wglMakeCurrent(NULL, NULL);
            wglDeleteContext(dummy_context.hRC);
            goto failure;
        }

        context->hRC = dummy_context.hRC;
        context->gl_version = 21;
        goto success;
    }

    if( major_ver == 3 && minor_ver < 1 ) {
        context->hRC = dummy_context.hRC;
        context->gl_version = 21;
        goto success;
    }

    if( !(wglChoosePixelFormatARB = (PFNWGLCHOOSEPIXELFORMATARBPROC)wglGetProcAddress("wglChoosePixelFormatARB")) ) {
        wglMakeCurrent(NULL, NULL);
        wglDeleteContext(dummy_context.hRC);
        goto failure;
    }

    if( !(wglCreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC)wglGetProcAddress("wglCreateContextAttribsARB")) ) {
        wglMakeCurrent(NULL, NULL);
        wglDeleteContext(dummy_context.hRC);
        goto failure;
    }

    num_formats = 0;
    if( wglChoosePixelFormatARB(context->hDC, (const int*)&pfd_attributes[0], 0, 1, (int*)&pixel_format, (UINT*)&num_formats) || num_formats ) {
        if( !SetPixelFormat(context->hDC, pixel_format, &pfd) ) {
            wglMakeCurrent(NULL, NULL);
            wglDeleteContext(dummy_context.hRC);
            goto failure;
        }
    }

    /*context_attributes[1] = major_ver;
    context_attributes[3] = minor_ver;
    context->gl_version   = major_ver * 10 + minor_ver;*/

    context_attributes[1] = 3;
    context_attributes[3] = 1;
    context->gl_version   = 31;

    if( !(context->hRC = (HGLRC)wglCreateContextAttribsARB(context->hDC, 0, (const int*)&context_attributes[0])) ) {
        wglMakeCurrent(NULL, NULL);
        wglDeleteContext(dummy_context.hRC);
        goto failure;
    }

    wglMakeCurrent(NULL, NULL);
    wglDeleteContext(dummy_context.hRC);

success:

    wglMakeCurrent(context->hDC, context->hRC);

    if( glewInit() != GLEW_OK ) goto failure;

    context->cg_context    = cgCreateContext();
    context->cg_vs_profile = cgGLGetLatestProfile(CG_GL_VERTEX);
    context->cg_ps_profile = cgGLGetLatestProfile(CG_GL_FRAGMENT);

    cgSetContextBehavior(context->cg_context, CG_BEHAVIOR_CURRENT);
    cgGLSetContextOptimalOptions(context->cg_context, context->cg_vs_profile);
    cgGLSetContextOptimalOptions(context->cg_context, context->cg_ps_profile);
    cgSetCompilerIncludeCallback(context->cg_context, &aglCgIncludeCallback);

    if( active_context ) wglMakeCurrent(active_context->hDC, active_context->hRC);
    else wglMakeCurrent(NULL, NULL);
    return TRUE;

failure:
    if( active_context ) wglMakeCurrent(active_context->hDC, active_context->hRC);
    else wglMakeCurrent(NULL, NULL);
    return FALSE;
}

aglContext* AGL_API waglCreateContext( const aglContextSettings* settings )
{
    aglContext* context = NULL;
    WNDCLASSEX win_class;
    char class_name[33] = { 0, };
    RECT client_area = { 0, 0, settings->width - 1, settings->height - 1 };

    context             = (aglContext*)malloc(sizeof(aglContext));
    context->id         = time(NULL);
    context->hWnd       = NULL;
    context->hDC        = NULL;
    context->hRC        = NULL;
    context->vsync      = settings->vsync;
    context->fullscreen = settings->fullscreen;
    context->cg_context = NULL;

    ZeroMemory(&win_class, sizeof(WNDCLASSEX));
    win_class.cbSize        = sizeof(WNDCLASSEX);
    win_class.style         = CS_VREDRAW | CS_HREDRAW;
    win_class.lpfnWndProc   = DefWindowProc;
    win_class.hInstance     = GetModuleHandle(NULL);
    win_class.hCursor       = LoadCursor(NULL, IDC_ARROW);
    win_class.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    win_class.hIconSm       = LoadIcon(NULL, IDI_APPLICATION);
    win_class.lpszClassName = &class_name[0];
    sprintf(&class_name[0], "agl_%u", context->id);

    if( !RegisterClassEx(&win_class) ) {
        aglFree(context);
        return NULL;
    }

    AdjustWindowRectEx(&client_area, WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW, FALSE, WS_EX_APPWINDOW | WS_EX_WINDOWEDGE);
    client_area.right = client_area.right - client_area.left + 1;
    client_area.bottom = client_area.bottom - client_area.top + 1;

    context->hWnd = CreateWindowExA(WS_EX_APPWINDOW | WS_EX_WINDOWEDGE, &class_name[0], "agl", WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW, 0, 0, client_area.right, client_area.bottom, NULL, NULL, GetModuleHandle(NULL), NULL);
    if( !context->hWnd ) {
        UnregisterClass(&class_name[0], GetModuleHandle(NULL));
        aglFree(context);
        return NULL;
    }

    if( !waglCreateHGLRC(settings, context) ) {
        UnregisterClass(&class_name[0], GetModuleHandle(NULL));
        DestroyWindow(context->hWnd);
        free(context);
        return NULL;
    }

    ShowWindow(context->hWnd, SW_SHOW);
    return context;
}

aglContext* AGL_API waglCreateContextEx( const aglContextSettings* settings, HWND hWnd )
{
    aglContext* context = NULL;

    context             = (aglContext*)aglAlloc(sizeof(aglContext));
    context->id         = -1;
    context->hWnd       = hWnd;
    context->hDC        = NULL;
    context->hRC        = NULL;
    context->vsync      = settings->vsync;
    context->fullscreen = settings->fullscreen;

    if( !waglCreateHGLRC(settings, context) ) {
        free(context);
        return NULL;
    }

    return context;
}

void AGL_API waglDestroyContext( aglContext* context )
{
    char class_name[33] = { 0, };

    assert(context);

    if( context == active_context ) {
        active_context = NULL;
        wglMakeCurrent(NULL, NULL);
    }

    cgDestroyContext(context->cg_context);
    wglDeleteContext(context->hRC);

    if( context->id != -1 ) {
        sprintf(&class_name[0], "agl_%u", context->id);
        UnregisterClass(&class_name[0], GetModuleHandle(NULL));
        DestroyWindow(context->hWnd);
    }

    aglFree(context);
}

HWND AGL_API waglGetWindowHandle( aglContext* context )
{
    assert(context);
    return context->hWnd;
}

void AGL_API aglSetActiveContext( aglContext* context )
{
    if( context == active_context ) return;
    active_context = context;
    if( active_context ) wglMakeCurrent(active_context->hDC, active_context->hRC);
    else wglMakeCurrent(NULL, NULL);
}

aglContext* AGL_API aglGetActiveContext( void )
{
    return active_context;
}

void AGL_API aglSwapBuffers( void )
{
    SwapBuffers(active_context->hDC);
}