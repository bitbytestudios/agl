////////////////////////////////////////////////////////////////////////////////
//
// This file is part of the Abstract Graphics Library.
//
// Copyright (c) 2012, bitbyte studios
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// 
////////////////////////////////////////////////////////////////////////////////

#include <AGL/win_agl.h>

#include <GL/wglext.h>

#include <time.h>

struct aglContext {
    uint32_t id;
    HWND     hWnd;
    HDC      hDC;
    HGLRC    hRC;
    unsigned vsync      : 1;
    unsigned fullscreen : 1;
    unsigned reserved   : 6;
    CGcontext cg_context;
    CGprofile cg_vs_profile;
    CGprofile cg_ps_profile;
};

static aglContext* active_context = NULL;

aglContext* AGL_API waglCreateContext( const aglContextSettings* settings )
{
    aglContext* context = NULL;

    WNDCLASSEX win_class;
    char class_name[33] = { 0, };
    RECT client_area = { 0, 0, settings->width - 1, settings->height - 1 };

    PIXELFORMATDESCRIPTOR pfd;
    int32_t pixel_format;
    
#if AGL_GL_VER > 21
    struct {
        HGLRC hRC;
    } dummy_context;

    int32_t major_ver, minor_ver;
    uint32_t num_formats;

    PFNWGLCHOOSEPIXELFORMATARBPROC  wglChoosePixelFormatARB;
    PFNWGLCREATECONTEXTATTRIBSARBPROC wglCreateContextAttribsARB;

    const int32_t pfd_attributes[] = {
        WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,
        WGL_ACCELERATION_ARB,   WGL_FULL_ACCELERATION_ARB,
        WGL_COLOR_BITS_ARB,     24,
        WGL_ALPHA_BITS_ARB,     0,
        WGL_DEPTH_BITS_ARB,     24,
        WGL_STENCIL_BITS_ARB,   8,
        WGL_DOUBLE_BUFFER_ARB,  GL_TRUE,
        WGL_SAMPLE_BUFFERS_ARB, settings->samples > 0 ? GL_TRUE : GL_FALSE,
        WGL_SAMPLES_ARB,        settings->samples,
        NULL, NULL
    };

    int32_t context_attributes[] = {
        WGL_CONTEXT_MAJOR_VERSION_ARB, 0,
        WGL_CONTEXT_MINOR_VERSION_ARB, 0, 
        WGL_CONTEXT_FLAGS_ARB, WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB,
        WGL_CONTEXT_PROFILE_MASK_ARB, WGL_CONTEXT_CORE_PROFILE_BIT_ARB,
        NULL, NULL
    };
#endif

    assert(settings);

    context = (aglContext*)aglAlloc(sizeof(aglContext));
    context->id = time(NULL);

    sprintf(&class_name[0], "agl_%u", context->id);

    ZeroMemory(&win_class, sizeof(WNDCLASSEX));
    win_class.cbSize        = sizeof(WNDCLASSEX);
    win_class.style         = CS_VREDRAW | CS_HREDRAW;
    win_class.lpfnWndProc   = DefWindowProc;
    win_class.hInstance     = GetModuleHandle(NULL);
    win_class.hCursor       = LoadCursor(NULL, IDC_ARROW);
    win_class.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    win_class.hIconSm       = LoadIcon(NULL, IDI_APPLICATION);
    win_class.lpszClassName = &class_name[0];

    if( !RegisterClassEx(&win_class) ) {
        aglFree(context);
        return NULL;
    }

    AdjustWindowRectEx(&client_area, WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW, FALSE, WS_EX_APPWINDOW | WS_EX_WINDOWEDGE);
    client_area.right = client_area.right - client_area.left + 1;
    client_area.bottom = client_area.bottom - client_area.top + 1;

    context->hWnd = CreateWindowExA(WS_EX_APPWINDOW | WS_EX_WINDOWEDGE, &class_name[0], "agl", WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_OVERLAPPEDWINDOW, 0, 0, client_area.right, client_area.bottom, NULL, NULL, GetModuleHandle(NULL), NULL);
    if( !context->hWnd ) {
        UnregisterClass(&class_name[0], GetModuleHandle(NULL));
        aglFree(context);
        return NULL;
    }

    context->hDC   = GetDC(context->hWnd);
    context->hRC   = NULL;
    context->vsync = settings->vsync;

    ZeroMemory(&pfd, sizeof(PIXELFORMATDESCRIPTOR));
    pfd.nSize        = sizeof(PIXELFORMATDESCRIPTOR);
    pfd.nVersion     = 1; 
    pfd.dwFlags      = PFD_DOUBLEBUFFER | PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW;  
    pfd.iPixelType   = PFD_TYPE_RGBA; 
    pfd.cColorBits   = 24;
    pfd.cAlphaBits   = 0;
    pfd.cDepthBits   = 24; 
    pfd.cStencilBits = 8;
    pfd.iLayerType   = PFD_MAIN_PLANE;

    pixel_format = ChoosePixelFormat(context->hDC, &pfd);
    if( !pixel_format ) goto failure;
    if( !SetPixelFormat(context->hDC, pixel_format, &pfd) ) goto failure;
#if AGL_GL_VER <= 21
    if( !(context->hRC = wglCreateContext(context->hDC)) ) goto failure;
#else
    if( !(dummy_context.hRC = wglCreateContext(context->hDC)) ) goto failure;

    wglMakeCurrent(context->hDC, dummy_context.hRC);
    glGetIntegerv(GL_MAJOR_VERSION, (GLint*)&major_ver);
    glGetIntegerv(GL_MINOR_VERSION, (GLint*)&minor_ver);

    if( major_ver <= 2 ) {
        wglMakeCurrent(NULL, NULL);
        wglDeleteContext(dummy_context.hRC);
        goto failure;
    }

    if( !(wglChoosePixelFormatARB = (PFNWGLCHOOSEPIXELFORMATARBPROC)wglGetProcAddress("wglChoosePixelFormatARB")) ) {
        wglMakeCurrent(NULL, NULL);
        wglDeleteContext(dummy_context.hRC);
        goto failure;
    }

    if( !(wglCreateContextAttribsARB = (PFNWGLCREATEBUFFERREGIONARBPROC)wglGetProcAddress("wglCreateContextAttribsARB")) ) {
        wglMakeCurrent(NULL, NULL);
        wglDeleteContext(dummy_context.hRC);
        goto failure;
    }

    num_formats = 0;
    if( wglChoosePixelFormatARB(context->hDC, (const int*)&pfd_attributes[0], 0, 1, (int*)&pixel_format, (UINT*)&num_formats) || num_formats ) {
        if( !SetPixelFormat(context->hDC, pixel_format, &pfd) ) {
            wglMakeCurrent(NULL, NULL);
            wglDeleteContext(dummy_context.hRC);
            goto failure;
        }
    }

    context_attributes[1] = major_ver;
    context_attributes[3] = minor_ver;

    if( !(context->hRC = (HGLRC)wglCreateContextAttribsARB(context->hDC, 0, (const int*)&context_attributes[0])) ) {
        wglMakeCurrent(NULL, NULL);
        wglDeleteContext(dummy_context.hRC);
        goto failure;
    }
#endif

    wglMakeCurrent(context->hDC, context->hRC);

    if( glewInit() != GLEW_OK ) goto failure;

    context->cg_context    = cgCreateContext();
    context->cg_vs_profile = CG_PROFILE_GLSLV;
    context->cg_ps_profile = CG_PROFILE_GLSLF;

    cgGLSetContextOptimalOptions(context->cg_context, CG_PROFILE_GLSLV);
    cgGLSetContextOptimalOptions(context->cg_context, CG_PROFILE_GLSLF);

    if( active_context ) wglMakeCurrent(active_context->hDC, active_context->hRC);
    else wglMakeCurrent(NULL, NULL);

    ShowWindow(context->hWnd, SW_SHOW);

    return context;

failure:
    if( active_context ) wglMakeCurrent(active_context->hDC, active_context->hRC);
    else wglMakeCurrent(NULL, NULL);

    aglFree(context);
    return NULL;
}

void AGL_API waglDestroyContext( aglContext* context )
{
    char class_name[33] = { 0, };

    assert(context);

    if( context == active_context ) {
        active_context = NULL;
        wglMakeCurrent(NULL, NULL);
    }

    cgDestroyContext(context->cg_context);

    wglDeleteContext(context->hRC);
    sprintf(&class_name[0], "agl_%u", context->id);
    UnregisterClass(&class_name[0], GetModuleHandle(NULL));

    aglFree(context);
}

HWND AGL_API waglGetWindowHandle( aglContext* context )
{
    assert(context);
    return context->hWnd;
}

void AGL_API aglSetActiveContext( aglContext* context )
{
    if( context == active_context ) return;
    active_context = context;
    if( active_context ) wglMakeCurrent(active_context->hDC, active_context->hRC);
    else wglMakeCurrent(NULL, NULL);
}

aglContext* AGL_API aglGetActiveContext( void )
{
    return active_context;
}

void AGL_API aglSwapBuffers( void )
{
    SwapBuffers(active_context->hDC);
}